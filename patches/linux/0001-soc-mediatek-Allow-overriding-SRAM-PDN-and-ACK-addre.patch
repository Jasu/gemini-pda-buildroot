From c2f5ae1cba1b14473834c845cc89419114b0141d Mon Sep 17 00:00:00 2001
From: Jasper Mattsson <jasu@njomotys.info>
Date: Sun, 26 Aug 2018 21:20:47 +0300
Subject: [PATCH] soc: mediatek: Allow overriding SRAM PDN and ACK addresses

On MT6797, MFG power domains (apart from mfg_async) are controlled from
separate SRAM registers. Add sram_ack_offs and sram_pdn_offs to SCP
power domain structure. If these are non-zero, that register is used
instead of the standard SRAM registers.

Signed-off-by: Jasper Mattsson <jasu@njomotys.info>
---
 drivers/soc/mediatek/mtk-scpsys.c | 36 +++++++++++++++++++++++--------
 1 file changed, 27 insertions(+), 9 deletions(-)

diff --git a/drivers/soc/mediatek/mtk-scpsys.c b/drivers/soc/mediatek/mtk-scpsys.c
index 5b24bb4bf..d11e3e476 100644
--- a/drivers/soc/mediatek/mtk-scpsys.c
+++ b/drivers/soc/mediatek/mtk-scpsys.c
@@ -120,6 +120,8 @@ struct scp_domain_data {
 	const char *name;
 	u32 sta_mask;
 	int ctl_offs;
+	int sram_ack_offs;
+	int sram_pdn_offs;
 	u32 sram_pdn_bits;
 	u32 sram_pdn_ack_bits;
 	u32 bus_prot_mask;
@@ -193,10 +195,16 @@ static int scpsys_power_on(struct generic_pm_domain *genpd)
 	struct scp_domain *scpd = container_of(genpd, struct scp_domain, genpd);
 	struct scp *scp = scpd->scp;
 	void __iomem *ctl_addr = scp->base + scpd->data->ctl_offs;
+	void __iomem *ack_addr = ctl_addr;
+	void __iomem *pdn_addr = ctl_addr;
 	u32 pdn_ack = scpd->data->sram_pdn_ack_bits;
-	u32 val;
+	u32 val, sram_val;
 	int ret, tmp;
 	int i;
+	if (scpd->data->sram_ack_offs)
+		ack_addr = scp->base + scpd->data->sram_ack_offs;
+	if (scpd->data->sram_pdn_offs)
+		pdn_addr = scp->base + scpd->data->sram_pdn_offs;
 
 	if (scpd->supply) {
 		ret = regulator_enable(scpd->supply);
@@ -235,8 +243,9 @@ static int scpsys_power_on(struct generic_pm_domain *genpd)
 	val |= PWR_RST_B_BIT;
 	writel(val, ctl_addr);
 
-	val &= ~scpd->data->sram_pdn_bits;
-	writel(val, ctl_addr);
+	sram_val = readl(pdn_addr);
+	sram_val &= ~scpd->data->sram_pdn_bits;
+	writel(sram_val, pdn_addr);
 
 	/* Either wait until SRAM_PDN_ACK all 0 or have a force wait */
 	if (MTK_SCPD_CAPS(scpd, MTK_SCPD_FWAIT_SRAM)) {
@@ -248,7 +257,7 @@ static int scpsys_power_on(struct generic_pm_domain *genpd)
 		usleep_range(12000, 12100);
 
 	} else {
-		ret = readl_poll_timeout(ctl_addr, tmp, (tmp & pdn_ack) == 0,
+		ret = readl_poll_timeout(ack_addr, tmp, (tmp & pdn_ack) == 0,
 					 MTK_POLL_DELAY_US, MTK_POLL_TIMEOUT);
 		if (ret < 0)
 			goto err_pwr_ack;
@@ -283,11 +292,18 @@ static int scpsys_power_off(struct generic_pm_domain *genpd)
 	struct scp_domain *scpd = container_of(genpd, struct scp_domain, genpd);
 	struct scp *scp = scpd->scp;
 	void __iomem *ctl_addr = scp->base + scpd->data->ctl_offs;
+	void __iomem *ack_addr = ctl_addr;
+	void __iomem *pdn_addr = ctl_addr;
 	u32 pdn_ack = scpd->data->sram_pdn_ack_bits;
-	u32 val;
+	u32 val, sram_val;
 	int ret, tmp;
 	int i;
 
+	if (scpd->data->sram_ack_offs)
+		ack_addr = scp->base + scpd->data->sram_ack_offs;
+	if (scpd->data->sram_pdn_offs)
+		pdn_addr = scp->base + scpd->data->sram_pdn_offs;
+
 	if (scpd->data->bus_prot_mask) {
 		ret = mtk_infracfg_set_bus_protection(scp->infracfg,
 				scpd->data->bus_prot_mask,
@@ -296,16 +312,18 @@ static int scpsys_power_off(struct generic_pm_domain *genpd)
 			goto out;
 	}
 
-	val = readl(ctl_addr);
-	val |= scpd->data->sram_pdn_bits;
-	writel(val, ctl_addr);
+	sram_val = readl(pdn_addr);
+	sram_val |= scpd->data->sram_pdn_bits;
+	writel(sram_val, pdn_addr);
 
 	/* wait until SRAM_PDN_ACK all 1 */
-	ret = readl_poll_timeout(ctl_addr, tmp, (tmp & pdn_ack) == pdn_ack,
+
+	ret = readl_poll_timeout(ack_addr, tmp, (tmp & pdn_ack) == pdn_ack,
 				 MTK_POLL_DELAY_US, MTK_POLL_TIMEOUT);
 	if (ret < 0)
 		goto out;
 
+	val = readl(ctl_addr);
 	val |= PWR_ISO_BIT;
 	writel(val, ctl_addr);
 
-- 
2.18.0

